#!/usr/bin/env node

/*

     ngserve - Tool for serving Norton Guide files as web pages.
     Copyright (C) 2017 David A Pearson

     This program is free software; you can redistribute it and/or modify it
     under the terms of the GNU General Public License as published by the
     Free Software Foundation; either version 2 of the license, or (at your
     option) any later version.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License along
     with this program; if not, write to the Free Software Foundation, Inc.,
     675 Mass Ave, Cambridge, MA 02139, USA.

*/

// Things we require.
const HTTP     = require( "http" );
const NG       = require( "../lib/jsNG" );
const NGParser = require( "../lib/jsNGParser" );
const NGError  = require( "../lib/jsNGError" );
const ngserve  = require( "commander" );

// Set up the command line.
ngserve
    .usage( "[options] <file ...>" )
    .version( NG.version )
    .description( "Simple HTTP server for serving a Norton Guide file" )
    .option( "-a, --no-advert",              "Don't show the ngserve/jsNG advert" )
    .option( "-g, --graph-text",             "Preserve \"graphical\" characters in the output" )
    .option( "-p, --port <n>",               "Port to serve on", parseInt )
    .option( "-s, --stylesheet <urlOrFile>", "Override the inbuilt stylesheet" )
    .parse( process.argv )

// Globals.
let css;

////////////////////////////////////////////////////////////////////////////
// Log something.
function log( s ) {
    console.log( ( new Date() ).toISOString() + " " + s );
}

////////////////////////////////////////////////////////////////////////////
// Emit the standad header.
function dumpHeader( res, title, extras = () => undefined ) {
    res.setHeader( "Content-Type", "text/html" );
    res.write( "<!DOCTYPE html>\n" );
    res.write( "<html>\n" );
    res.write( "<head>\n" );
    res.write( '<meta name="viewport" content="width=device-width, initial-scale=1">\n' );
    res.write( '<meta charset="utf-8">\n' );
    res.write( `<title>${title}</title>\n` );
    res.write( `<link rel="stylesheet" type="text/css" href="${ngserve.stylesheet}" />\n` );
    extras( res );
    res.write( "</head>\n" );
    res.write( "<body>\n" );
}

////////////////////////////////////////////////////////////////////////////
// Emit the standad footer.
function dumpFooter( res, guide ) {

    if ( ngserve.advert ) {
        res.write( '<footer class="box">\n' );
        res.write( `Served by <a href="https://github.com/davep/jsNG">jsNG/ngserve v${NG.version}</a>\n` );
        res.write( "</footer>\n" );
    }

    res.write( "</body>\n" );
    res.write( "</html>\n" );
}

////////////////////////////////////////////////////////////////////////////
// Emit colour attribute options for the stylesheet.
function colourOptions() {
    const COLOURS = [
        "black",
        "navy",
        "green",
        "teal",
        "maroon",
        "purple",
        "olive",
        "silver",
        "gray",
        "blue",
        "lime",
        "aqua",
        "red",
        "fuchsia",
        "yellow",
        "white"
    ];
    let s = "";

    for ( let i = 0; i < COLOURS.length; i++ ) {
        s += `
span.bg${i} {
  background: ${COLOURS[ i ]}
}

span.fg${i} {
  color: ${COLOURS[ i ]}
}
`
    }

    return s;
}

////////////////////////////////////////////////////////////////////////////
// Serve the stylesheet for the guide.
function serveCSS( res ) {

    res.setHeader( "Content-Type", "text/css" );

    // If we've got an alternative stylesheet to serve..
    if ( css ) {
        // ...serve that.
        res.write( css );
    } else {
        // ...otherwise use our own.
        res.write( `
body {
  font-family: sans-serif;
  background: dimgray;
}

footer {
  clear: both;
  font-size: 70%;
  color: silver;
  padding: 1ex;
}

.box {
  border: solid 1px silver;
  box-shadow: 4px 4px 7px 0px rgba( 0, 0, 0, 0.2 );
  background: navy;
  color: silver;
}

a {
  text-decoration: none;
  color: inherit;
}

nav a:hover, nav a:hover *, article a:hover, article a:hover * {
  background: red;
  color: white;
}

header nav {
  padding: 0;
  margin-bottom: 1ex;
}

header nav ul {
  padding-left: 1ex;
  padding-top: 0;
  padding-bottom: 0;
}

header nav ul li {
  display: inline-block;
  color: dimgray;
}

header nav ul li::after {
  content: " |";
  color: silver;
}

header nav a {
  color: white;
  padding-left: 1em;
  padding-right: 1em;
}

header nav span {
  padding-left: 1em;
  padding-right: 1em;
}

section nav.menu {
  float: left;
  padding-right: 1ex;
  margin-right: 1ex;
  margin-bottom: 1ex;
}

section nav.menu ul {
  list-style: none;
  padding-left: 1ex;
}

section nav.menu > ul > li {
  color: white;
}

section nav.menu a {
  display: block;
}

nav.seeAlso {
  border-top: solid 1px silver;
  white-space: normal;
  padding-bottom: 0;
  margin-bottom: 0;
}

nav.seeAlso ul {
  padding-left: 0.5em;
  padding-bottom: 0;
  margin-bottom: 0;
}

nav.seeAlso ul li:first-child {
  color: white;
}

nav.seeAlso ul li {
  display: inline-block;
  margin-right: 1em;
}

section article {
  overflow: scroll;
  font-family: 'Roboto Mono', monospace;
  padding: 0.5em;
  margin-bottom: 1ex;
  white-space: pre;
}

section article h1 {
  color: white;
  margin-bottom: 0;
}

section article ul {
  list-style: none;
  padding-left: 1ex;
  white-space: normal;
}

section article span.ngb {
  color: white;
}

section article span.ngu {
  text-decoration: underline;
}
${colourOptions()}
section article a {
  width: 100%;
  display: inline-block;
}

@media screen and (max-width: 480px) {

  .box {
    box-shadow: none;
  }

  section nav.menu {
    float: none;
    margin-right: 0;
  }

  section article {
    clear: both;
  }

  header nav {
    padding: 0;
    margin: 0;
    text-align: center;
  }

  header nav ul, header nav ul a, header nav ul span {
    padding: 0;
  }

  header nav ul li {
    padding-left: 0.5em;
    padding-right: 0.5em;
    display: inline;
  }

  header nav ul li::after {
    content: "";
  }

  header nav ul li:nth-child(2):after {
    content: "\\A";
    white-space: pre;
  }

  section article {
    font-size: 80%;
  }
}
`);
    }
}

////////////////////////////////////////////////////////////////////////////
// Escape problematic HTML characters.
function unHTML( s ) {
    return s
        .replace( /&/g, "&amp;"  )
        .replace( /</g, "&lt;"   )
        .replace( />/g, "&gt;"   )
        .replace( /"/g, "&quot;" )
        .replace( /'/g, "&#039;" );
}

////////////////////////////////////////////////////////////////////////////
// Convert text from DOS to DOS-a-like.
function unDOSify( s ) {
    return ( ngserve.graphText ? NGParser.Tool.makeDOSish : NGParser.Tool.makePlain )( s );
}

////////////////////////////////////////////////////////////////////////////
// Have a guide URL handle that we might have arguments in the URL.
function url( url, arg ) {
    if ( arg ) {
        return `../${url}`;
    }
    return url;
}

////////////////////////////////////////////////////////////////////////////
// Dump the top navigation section.
function dumpTopNav( res, guide, entry = false, arg ) {

    const addJump = ( name, has, pos ) => {
        res.write( "<li>" );
        if ( has ) {
            res.write( `<a href="${pos}">${name}</a>`)
        } else {
            res.write( `<span>${name}</span>` );
        }
        res.write( "</li>\n" );
    };

    res.write( '<header>\n<nav class="box">\n<ul>\n' );

    addJump( "Guides",   true,                         "/" );
    addJump( "About",    guide,                        url( "about",                   arg ) );
    addJump( "Previous", entry && entry.hasPrevious(), url( entry && entry.previous(), arg ) );
    addJump( "Up",       entry && entry.hasParent(),   url( entry && entry.parent(),   arg ) );
    addJump( "Next",     entry && entry.hasNext(),     url( entry && entry.next(),     arg ) );

    res.write( "</ul>\n</nav>\n</header>\n" );
}

////////////////////////////////////////////////////////////////////////////
// Wrap a function call in the general head/foot code.
function dumper( res, title, guide, f ) {
    dumpHeader( res, title );
    dumpTopNav( res, guide );
    res.write( "<section>\n" );
    dumpMenu( res, guide );
    res.write( '<article class="box">' );
    f( res, guide );
    res.write( "</article>\n" );
    res.write( "</section>\n" );
    dumpFooter( res, guide );
}

////////////////////////////////////////////////////////////////////////////
// Dump the "About" of the guide.
function dumpAbout( res, guide ) {
    dumper( res, `About ${unHTML( NGParser.Tool.makeDOSish( guide.title() ) )}`, guide, () => {
        res.write( `<h1>About "${unHTML( NGParser.Tool.makeDOSish( guide.title() ) )}".</h1><hr />\n` );
        for ( let line of guide.credits() ) {
            res.write( unHTML( unDOSify( line ) ) + "\n" );
        }
    } );
}

////////////////////////////////////////////////////////////////////////////
// Dump an error message.
function dumpError( res, guide, error ) {
    dumper( res, "Error", guide, () => res.write( error ) );
}

////////////////////////////////////////////////////////////////////////////
// Dump a menu to the browser.
function dumpMenu( res, guide, arg ) {

    if ( guide && ( guide.menus().length > 0 ) ) {
        res.write( '<nav class="menu box">\n<ul>\n' );

        for ( let menu of guide.menus() ) {

            res.write( `<li>${menu.title()}</li>\n` );
            res.write( "<ul>\n" );

            for ( let option of menu.options() ) {
                res.write( `<li><a href="${url( option.offset, arg )}">${option.prompt}</a></li>\n` );
            }
            res.write( "</ul>\n" );
        }

        res.write( "</ul>\n</nav>\n" );
    }

}

////////////////////////////////////////////////////////////////////////////
// Convert an NG line to HTML.
function toHTML( line ) {
    const stack = [];
    let   s     = "";
    ( new NGParser.Line.Parser( {

        text: t => s += unHTML( unDOSify( t ) ),

        colour: c => {
            s += `<span class="fg${ c & 0xF } bg${ c >> 4 }">`;
            stack.push( "</span>" );
        },

        normal: t => {
            s += stack.reverse().join( "" );
            stack.length = 0;
        },

        bold: () => {
            s += '<span class="ngb">';
            stack.push( "</span>" );
        },

        unbold: () => {
            s += "</span>";
            stack.pop();
        },

        reverse: () => {
            s += '<span class="ngr">';
            stack.push( "</span>" );
        },

        unreverse: () => {
            s += "</span>";
            stack.pop();
        },

        underline: () => {
            s += '<span class="ngu">';
            stack.push( "</span>" );
        },

        ununderline: () => {
            s += "</span>",
            stack.pop();
        },

        charVal: c => s += unHTML( unDOSify( String.fromCharCode( c ) ) )

    } ) ).parse( line );
    return s + stack.reverse().join( "" );
}

////////////////////////////////////////////////////////////////////////////
// Return a title for the entry.
function entryTitle( guide, entry ) {

    const SEP = " » ";

    let title = unHTML( NGParser.Tool.makeDOSish( guide.title() ) );

    if ( entry.hasParentMenu() ) {
        title += SEP + unHTML( guide.menus()[ entry.parentMenu() ].title() );
        if ( entry.hasParentPrompt() ) {
            title += SEP + unHTML( guide.menus()[ entry.parentMenu() ].prompts()[ entry.parentPrompt() ] );
        }
    }

    return title;
}

////////////////////////////////////////////////////////////////////////////
// Dump an entry to the browser.
function dumpEntry( res, guide, pos, source ) {

    const entry = guide.loadEntry( parseInt( pos ) );

    dumpHeader( res, entryTitle( guide, entry ), ( res ) => {
        if ( entry.hasPrevious() ) res.write( `<link rel="prev" href="${entry.previous()}" title="Previous entry" />\n` );
        if ( entry.hasNext()     ) res.write( `<link rel="next" href="${entry.next()}" title="Next entry" />\n` );
        res.write( `<link rel="home" href="./" title="Home" />\n` );
    } );

    dumpTopNav( res, guide, entry, source );

    res.write( "<section>\n" );

    dumpMenu( res, guide, source );

    const converter = source ? unDOSify : toHTML;

    res.write( '<article class="box">' );
    for ( let i = 0; i < entry.lineCount(); i++ ) {
        if ( entry.isShort() && guide.isEntryAt( entry.offsets()[ i ] ) ) {
            res.write( `<a href="${url( entry.offsets()[ i ], source )}">${converter( entry.lines()[ i ] )}</a>\n` );
        } else {
            res.write( `${converter( entry.lines()[ i ] )}\n`);
        }
    }

    if ( entry.hasSeeAlso() ) {
        res.write( '<nav class="seeAlso">\n' );
        res.write( "<ul>\n<li>See Also:</li>\n" );
        for ( let seeAlso of entry.seeAlso().options() ) {
            res.write( `<li><a href="${url( seeAlso.offset, source )}">${unHTML( seeAlso.prompt )}</a></li>\n` );
        }
        res.write( "</ul>\n" );
        res.write( "</nav>\n" );
    }

    res.write( "</article>\n" );
    res.write( "</section>\n" );

    dumpFooter( res, guide );

}

////////////////////////////////////////////////////////////////////////////
// Generate a unique ID for the given guide.
function guideKey( guide ) {
    return require( "crypto" ).createHash( "md5" ).update( guide ).digest( "hex" );
}

////////////////////////////////////////////////////////////////////////////
// Given a guide ID, get its base filename.
function guideBasename( guides, guide ) {
    const path = require( "path" );
    if ( guides.has( guide ) ) {
        return path.basename( guides.get( guide ).filename() );
    }
    return guide;
}

////////////////////////////////////////////////////////////////////////////
// Given a guide ID, get its filename.
function guideFilename( guides, guide ) {
    if ( guides.has( guide ) ) {
        return guides.get( guide ).filename();
    }
    return guide;
}

////////////////////////////////////////////////////////////////////////////
// Load up the list of guides we want to serve.
function initGuidesToServe( list ) {

    const path   = require( "path" );
    const guides = new Map();

    for ( let guide of list ) {
        if ( guides.has( guideKey( path.resolve( guide ) ) ) ) {
            log( `Ignoring ${guide} as a duplicate.` );
        } else {
            log( `Serving ${path.basename( guide )} from "${path.resolve( guide )}"` );
            try {
                guides.set( guideKey( path.resolve( guide ) ), new NG.Guide( guide ).open() );
            } catch ( e ) {
                if ( e instanceof NGError ) {
                    log( `Ignoring ${guide} as it doesn't appear to be a Norton Guide file.` );
                } else {
                    throw e;
                }
            }
        }
    }

    return guides;
}

////////////////////////////////////////////////////////////////////////////
// Serve a menu of guides.
function serveGuideList( res, guides ) {
    dumper( res, "Available Guides", null, () => {
        res.write( "<ul>\n" );
        for ( let [ id, ng ] of [ ...guides.entries() ].sort( ( a, b ) => {
            if ( a[ 1 ].title() < b[ 1 ].title() ) return -1;
            if ( a[ 1 ].title() > b[ 1 ].title() ) return 1;
            return 0;
        } ) ) {
            res.write( `<li><a href="${id}/">${unHTML( unDOSify( ng.title() ) )}</a></li>\n` );
        }
        res.write( "</ul>\n" );
    } );
}

////////////////////////////////////////////////////////////////////////////
// Serve the given guide.
function serveGuide( res, guides, source, part, arg ) {

    // Do we have the requested guide?
    if ( guides.has( source ) ) {

        // It does. Pull it out.
        const guide = guides.get( source );

        // If what we're being asked for is empty, assume it's the first entry
        // that we're after.
        part = ( part === "" ? guide.firstEntry() : part );

        // Set some default headers.
        res.setHeader( "Server", `ngserve/jsNG/${NG.version}` );

        // Asking for the about section?
        if ( part === "about" ) {
            dumpAbout( res, guide );
        } else if ( guide.isEntryAt( parseInt( part ) ) ) {
            // Asking for an entry.
            dumpEntry( res, guide, part, arg === "source" );
        } else {
            // Don't have it!
            res.statusCode = 404;
            log( `There is no such entry in ${guideFilename( guides, source )}.` );
            dumpError( res, guide, `There is no such entry in ${guideBasename( guides, source )}.` );
        }

    } else {
        res.statusCode = 404;
        log( `${source} is not an available guide.` );
        dumpError( res, null, `${source} is not an available guide.` );
    }
}

////////////////////////////////////////////////////////////////////////////
// Figure out how we'll serve the stylesheet.
function processCSS() {

    const fs = require( "fs" );

    // If we've been given a stylesheet and it appears to exist in the
    // filesystem...
    if ( ngserve.stylesheet && fs.existsSync( ngserve.stylesheet ) ) {

        const size   = fs.statSync( ngserve.stylesheet ).size;
        const buffer = new Buffer( size );
        const f      = fs.openSync( ngserve.stylesheet, "r" );

        log( `Serving stylesheet from ${ngserve.stylesheet}.` );

        try {
            if ( fs.readSync( f, buffer, 0, size, 0 ) === size ) {
                // Having loaded the content of the file, we hold it locally
                // and then go back to serving via the usual mechanism.
                css                = buffer.toString();
                ngserve.stylesheet = "/css";
            } else {
                throw new NGError( "Could not read the whole of the stylesheet." );
            }
        } finally {
            fs.closeSync( f );
        }
    }
}

////////////////////////////////////////////////////////////////////////////
// Main code. If we have guides to serve...
if ( ngserve.args.length > 0 ) {

    // Create the list of guides to serve.
    const guides = initGuidesToServe( ngserve.args );

    // Set up defaults.
    ngserve.port       = ngserve.port       || 8080;
    ngserve.stylesheet = ngserve.stylesheet || "/css";

    // Figure out how we're going to serve the stylesheet.
    processCSS();

    HTTP.createServer( ( req, res ) => {

        try {

            // Log the request.
            log( `${req.connection.remoteAddress} ${req.method} ${req.url} ${req.headers[ 'user-agent' ]}` );

            // See what we're being asked for.
            const request = req.url.split( "/" );
            const source  = request[ 1 ];
            const part    = request[ 2 ];
            const arg     = request[ 3 ];

            // Assume we're going to handle things.
            res.statusCode = 200;

            // If we're asking for a source of some description...
            if ( source ) {
                // If it's the stylesheet...
                if ( source === "css" ) {
                    // ...serve that.
                    serveCSS( res );
                } else {
                    // ...all other things should be a guide.
                    serveGuide( res, guides, source, part, arg );
                }
            } else {
                // Looks like we're being asked for the main guide list.
                serveGuideList( res, guides );
            }

        } catch ( e ) {
            log( "Internal error:\n\n" + e.message );
            if ( res.headersSent ) {
                res.write( "Internal error:\n\n" + unHTML( e.message ) );
            } else {
                res.statusCode = 500;
                dumpError( res, null, "Internal error:\n\n" + unHTML( e.message ) );
            }
        } finally {
            res.end();
        }

    } ).listen( ngserve.port, () => {
        log( `Serving on http://localhost:${ngserve.port}` );
    } );

}
